// =============================================================================
// NexusD - Sidecar Protocol Buffer Definitions
// =============================================================================
//
// Defines the SidecarService for local application communication.
// This is the API that thin clients (Python, C++, Rust, etc.) use.
//
// Copyright (c) 2024 NexusD Contributors
// License: MIT
// =============================================================================

syntax = "proto3";

package nexusd.sidecar;

option cc_enable_arenas = true;

// =============================================================================
// SidecarService - Local application RPC service
// =============================================================================
// This service runs on app_port (default 50051) and binds to 127.0.0.1.
// It handles all pub/sub operations for local applications.

service SidecarService {
    // Publish sends a message to a topic.
    // The daemon routes it to all subscribers (local and remote).
    rpc Publish(PublishRequest) returns (PublishResponse);

    // Subscribe opens a server-streaming RPC.
    // The client receives messages for the requested topics until cancelled.
    rpc Subscribe(SubscribeRequest) returns (stream MessageEvent);

    // ResumeSubscribe resumes a previously paused subscription.
    // Supports gap recovery by replaying buffered messages since last sequence.
    rpc ResumeSubscribe(ResumeSubscribeRequest) returns (stream MessageEvent);

    // Unsubscribe removes a subscription.
    // The subscription_id is returned by Subscribe in the first MessageEvent.
    // Set pause=true to preserve state for later resume (e.g., during upgrades).
    rpc Unsubscribe(UnsubscribeRequest) returns (UnsubscribeResponse);

    // GetTopics returns the list of topics with active subscribers.
    // Useful for debugging and monitoring.
    rpc GetTopics(GetTopicsRequest) returns (GetTopicsResponse);

    // GetPeers returns information about discovered mesh peers.
    // Useful for debugging and monitoring.
    rpc GetPeers(GetPeersRequest) returns (GetPeersResponse);
}

// =============================================================================
// Publish Messages
// =============================================================================

message PublishRequest {
    // The topic to publish to.
    string topic = 1;

    // The message payload (opaque bytes).
    bytes payload = 2;

    // Content type hint (e.g., "application/json").
    string content_type = 3;

    // If true, the message is retained for late subscribers.
    bool retain = 4;

    // Optional correlation ID for request-response patterns.
    string correlation_id = 5;

    // Time-to-live in milliseconds. 0 = no expiration.
    int64 ttl_ms = 6;
}

message PublishResponse {
    // True if the message was accepted for routing.
    bool success = 1;

    // Unique message ID assigned by the daemon.
    string message_id = 2;

    // Number of subscribers the message was routed to.
    // Includes both local and remote subscribers.
    int32 subscriber_count = 3;

    // Error message if success is false.
    string error_message = 4;

    // Number of subscribers where message was dropped due to backpressure.
    int32 subscribers_dropped = 5;

    // Number of subscribers where publisher was blocked waiting for queue space.
    int32 subscribers_blocked = 6;
}

// =============================================================================
// Subscribe Messages
// =============================================================================

// Gap recovery mode for ResumeSubscribe.
enum GapRecoveryMode {
    // No gap recovery - just resume with live messages.
    GAP_RECOVERY_NONE = 0;

    // Only re-deliver retained messages for subscribed topics.
    GAP_RECOVERY_RETAINED_ONLY = 1;

    // Replay messages from server buffer since last sequence.
    // Falls back to retained if buffer doesn't have enough history.
    GAP_RECOVERY_REPLAY_BUFFER = 2;
}

message SubscribeRequest {
    // List of topic patterns to subscribe to.
    // Exact match only in v1.0 (wildcard support planned for v2.0).
    repeated string topics = 1;

    // Client-provided identifier for this subscription (for logging).
    // Recommended format: "{hostname}-{pid}" (e.g., "myapp-host-12345").
    string client_id = 2;

    // If true, request retained messages for subscribed topics.
    bool receive_retained = 3;

    // Maximum messages to buffer before dropping (0 = unlimited).
    // Helps slow consumers avoid unbounded memory growth.
    int32 max_buffer_size = 4;
}

message ResumeSubscribeRequest {
    // The subscription ID to resume (from previous SubscriptionInfo).
    string subscription_id = 1;

    // Topics to resume (must match original subscription).
    repeated string topics = 2;

    // Last message ID received by client (for gap detection).
    string last_message_id = 3;

    // Last sequence number received per topic.
    // Key: topic name, Value: last sequence number.
    // Used for precise gap recovery.
    map<string, int64> last_sequence_per_topic = 4;

    // How to handle gaps when messages were missed.
    GapRecoveryMode gap_recovery_mode = 5;

    // If true, also receive retained messages after replay.
    bool receive_retained = 6;
}

// MessageEvent is streamed to subscribers.
// The first event contains metadata; subsequent events are messages.
message MessageEvent {
    oneof event {
        // First message after Subscribe - contains subscription metadata.
        SubscriptionInfo subscription_info = 1;

        // A published message matching the subscription.
        Message message = 2;

        // Indicates a retained message is being delivered.
        Message retained_message = 3;

        // Heartbeat to keep connection alive (sent every 30s if idle).
        Heartbeat heartbeat = 4;

        // A replayed message from buffer (during gap recovery).
        Message replay_message = 5;

        // Signals that replay phase is complete for a topic.
        ReplayComplete replay_complete = 6;

        // Warning that messages are being dropped due to backpressure.
        // Sent periodically when queue is under pressure.
        BackpressureWarning backpressure_warning = 7;
    }
}

// Warning sent to subscribers when messages are being dropped.
message BackpressureWarning {
    // Total messages dropped since last warning (or subscription start).
    uint64 messages_dropped = 1;

    // Current queue depth for this subscriber.
    uint64 queue_depth = 2;

    // Queue limit configured for this subscriber.
    uint64 queue_limit = 3;

    // Reason for backpressure.
    // Values: "slow_consumer", "burst", "ttl_expired"
    string reason = 4;

    // Messages expired due to TTL since last warning.
    uint64 messages_expired = 5;

    // Oldest message age in queue (milliseconds).
    // Useful for detecting slow consumption.
    int64 oldest_message_age_ms = 6;
}

message SubscriptionInfo {
    // Unique subscription ID assigned by the daemon.
    // Use this for Unsubscribe.
    // Format: sub-{cluster}-{client_id}-{topic_hash}-{random}
    string subscription_id = 1;

    // List of topics actually subscribed to.
    repeated string topics = 2;

    // Timestamp when subscription was established.
    int64 timestamp_ms = 3;

    // True if this is a resumed subscription and gaps were detected.
    bool gap_detected = 4;

    // Number of messages that were missed (if gap_detected is true).
    // -1 means unknown (buffer overflow, can't determine exact count).
    int32 missed_message_count = 5;

    // True if replay phase is starting (messages will be replay_message events).
    bool replay_started = 6;
}

message ReplayComplete {
    // The topic that replay completed for.
    string topic = 1;

    // Number of messages that were replayed.
    int32 replayed_count = 2;

    // The latest sequence number after replay.
    // Client should track this for future reconnections.
    int64 latest_sequence = 3;
}

message Message {
    // Unique message ID.
    string message_id = 1;

    // The topic this message was published to.
    string topic = 2;

    // The message payload.
    bytes payload = 3;

    // Content type hint.
    string content_type = 4;

    // When the message was originally published.
    int64 timestamp_ms = 5;

    // The source node that first published this message.
    string source_node_id = 6;

    // Correlation ID if set by publisher.
    string correlation_id = 7;

    // Monotonically increasing sequence number per topic.
    // Used for ordering and gap detection.
    // Note: Ordering is guaranteed within a topic only.
    // Cross-topic ordering is NOT guaranteed.
    int64 sequence_number = 8;
}

message Heartbeat {
    // Current server timestamp.
    int64 timestamp_ms = 1;
}

// =============================================================================
// Unsubscribe Messages
// =============================================================================

message UnsubscribeRequest {
    // The subscription ID to cancel.
    string subscription_id = 1;

    // If true, preserve subscription state for later resume.
    // Use this during graceful shutdowns or software upgrades.
    // The subscription can be resumed within pause_ttl.
    bool pause = 2;
}

message UnsubscribeResponse {
    // True if the subscription was found and cancelled/paused.
    bool success = 1;

    // Error message if success is false.
    string error_message = 2;

    // If pause was true, how long the paused state will be kept (ms).
    // After this time, the subscription must be recreated.
    int64 pause_ttl_ms = 3;
}

// =============================================================================
// Monitoring Messages
// =============================================================================

message GetTopicsRequest {
    // If true, include subscriber counts.
    bool include_counts = 1;
}

message GetTopicsResponse {
    // Map of topic name to subscriber count.
    map<string, int32> topics = 1;
}

message GetPeersRequest {
    // If true, include full peer state (topics, etc.).
    bool include_state = 1;
}

message GetPeersResponse {
    // List of discovered peers.
    repeated PeerInfo peers = 1;
}

message PeerInfo {
    // The peer's instance UUID.
    string instance_uuid = 1;

    // The peer's gRPC endpoint (ip:port).
    string endpoint = 2;

    // When we last received a beacon from this peer.
    int64 last_seen_ms = 3;

    // The peer's cluster ID (should match ours).
    string cluster_id = 4;

    // The peer's topic state hash.
    uint64 topic_state_hash = 5;

    // If include_state was true, the peer's subscribed topics.
    repeated string topics = 6;

    // Peer status: "alive", "suspected", "dead"
    string status = 7;
}
